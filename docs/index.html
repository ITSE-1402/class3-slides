<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <title>Class 3: Chapter 9: Case Study: word play / Chapter 10: Lists</title>
        <link rel="stylesheet" href="./css/reveal.css">
        <link rel="stylesheet" href="./css/theme/moon.css" id="theme">
        <link rel="stylesheet" href="./css/highlight/zenburn.css">
        <link rel="stylesheet" href="./css/print/paper.css" type="text/css" media="print">
          <link rel="stylesheet" href="./_assets/assets/custom.css">


    </head>
    <body>

        <div class="reveal">
            <div class="slides"><section  data-markdown><script type="text/template">

### ITSE-1402 Intermediate Python
<span style="font-family:Helvetica Neue; font-weight:bold; color:#e49436">Class 3: Chapter 9: Case Study: word play / Chapter 10: Lists</span>
<br /><br />
##### [https://coder.run/1402-class3](https://coder.run/1402-class3)

</script></section><section ><section data-markdown><script type="text/template">

##### Chapter 9: Case Study: word play

##### Code: [https://coder.run/1402-chap9](https://coder.run/1402-chap9)

</script></section><section data-markdown><script type="text/template">

In this chapter we will be looking at a list of 113,809 words made from a collection of valid crossword words and words used in other games. You will be searching this list for various things. This chapter should remind us of how to work with files and then reinforce the use of functions and manipulation of objects.

</script></section><section data-markdown><script type="text/template">

Beyond what you presently should know, you will need to know how to open an file and read it contents. 

```python
# Opening a file is very easy:
fin = open('words.txt')
```

</script></section><section data-markdown><script type="text/template">

Once we open a file, we need to know how to read it. This, luckily, is also very simple:

```python
fin = open('words.txt')
print(fin.readline())
# in our case, the ouput will be:
# "aa\r\n"
```

</script></section><section data-markdown><script type="text/template">

"\r" and "\n" are both whitespace characters indicating a new line and should be stripped out for it to be useful. This can be done as follows:

```python
fin = open('words.txt')
print(fin.readline().strip())
# The output this time would be:
# "aa"
```

</script></section><section data-markdown><script type="text/template">

Assuming you continue on this way, you can grab the next line the same way:

```python
fin = open('words.txt')
print(fin.readline().strip())
# "aa"
print(fin.readline().strip())
# "aah"
```

</script></section><section data-markdown><script type="text/template">

You can also treat the file as an interable and make the parsing of it a lot easier:

```python
fin = open('words.txt')

for line in fin:
    print (line.strip())
# "aa"
# "aah"
# ...
# "zymurgy"
```

</script></section><section data-markdown><script type="text/template">

<pre class="stretch"><code class="python" data-trim data-noescape>
# Grading Guidelines:
# - Variable 'answer' must be a list containing 3 words
# - List does not have to be in alphabetical order (but will be sorted)
# - Words must remain unaltered from file (e.g. lower case, no whitespace, etc)
#
# Answer Example: 
# - answer = ['aWord', 'anotherWord', 'oneMoreWord']
#
# 1. Write a program that reads words.txt and adds the words with more 
# than 20 characters (not counting whitespace) to a list which is returned
# by the function.
</code></pre>

</script></section><section data-markdown><script type="text/template">

<pre class="stretch"><code class="python" data-trim data-noescape>
# Grading Guidelines:
# - Variable 'answer' must be a list containing both answers
# - Variable 'answer1' must be a list containing all words without e
# - Variable 'answer2' must be a int or float containing % of words without e
# - Answers will be converted to numbers and graded with a buffer:
# -- 'answer1' +/- 1%
# -- 'answer2' +/- 5%
# 
# Answer Example: 
# - answer1 = ['aWord', 'anotherWord', 'oneMoreWord']
# - answer2 = 28
# - answer = [answer1, answer2]
#
#
# In 1939 Ernest Vincent Wright published a 50,000 word novel called Gadsby 
# that does not contain the letter "e". Since "e" is the most common letter in `
# English, that's not easy to do.
#
# In fact, it is difficult to construct a solitary thought without using that 
# most common symbol. It is slow going at first, but with caution and hours of 
# training you can gradually gain facility.
# 
# All right, I'll stop now.
# 
# 1. Write a function "has_no_e" that returns True if the given word doesn't 
# have the letter "e" in it. Use the function to create a list of only the
# words that have no "e". Then compute the percentage of words that have no "e".
# Return these as objects in a list "answer".
</code></pre>

</script></section><section data-markdown><script type="text/template">

<pre class="stretch"><code class="python" data-trim data-noescape>
# Grading Guidelines:
# - No answer variables needed. Grading script will call functions.
# - Function 'avoids' should return boolean True/False depending on if
# forbidden letters are found
# - Function 'lowest_avoidance' should return a list of 5 lowercase letters
#
#
# 1. Write a function named 'avoids' that takes a word and a string of forbidden 
# letters, and that returns True if the word doesn't use any of the forbidden 
# letters.
# 
# 2. Write a function named 'lowest_avoidance' that finds the 5 letters excluding
#  the fewest number of words and returns them in a list.
</code></pre>

</script></section><section data-markdown><script type="text/template">

<pre class="stretch"><code class="python" data-trim data-noescape>
# Grading Guidelines:
# - No answer variables needed. Grading script will call function.
# - Function 'uses_only' should return boolean True/False depending on if
# word only uses those letters
#
# 1. Write a function named uses_only that takes a word and a string of letters, 
# and that returns True if the word contains only letters in the list.
</code></pre>

</script></section><section data-markdown><script type="text/template">

<pre class="stretch"><code class="python" data-trim data-noescape>
# Grading Guidelines:
# - No answer variable needed for question 1. Grading script will call function.
# Variable 'answer2' is needed for answer 2.
# - Function 'uses_all' should return boolean True/False depending on if
# all the letters specified are in the word. 
# - Variable 'answer2' should be the number of word that use all the vowels 
# "aeiou".
#
# 1. Write a function named uses_all that takes a word and a string of required 
# letters, and that returns True if the word uses all the required letters at 
# least once.
#
# 2. How many words are there that use all the vowels aeiou? How about
# aeiouy?
</code></pre>

</script></section><section data-markdown><script type="text/template">

<pre class="stretch"><code class="python" data-trim data-noescape>
# Grading Guidelines:
# - No answer variables needed. Grading script will call function.
# - Function 'is_abecedarian' should return boolean True/False depending on if
# the letters are in alphabetical order.
#
# 1. Write a function called is_abecedarian that returns True if the letters in
# a word appear in alphabetical order (double letters are ok).
</code></pre>

</script></section><section data-markdown><script type="text/template">

You should have seen a recurring pattern in those questions. They all could be solved with the following search pattern that is from chapter 7:

```python
def has_no_e(word):
    for letter in word:
        if letter == 'e':
            return False
    return True
```
</script></section><section data-markdown><script type="text/template">

This can be coded much more cleanly (and a tiny faster) by simply checking if the letter is "in" the word instead though:

```python
def has_no_e(word):
    if 'e' in word:
        return False
    return True
```

</script></section><section data-markdown><script type="text/template">

This same principle cannot be applied though to the "avoids" function you wrote though.

```python
def avoids(word, forbidden):
    for letter in word:
        if letter in forbidden:
            return False
    return True
```

<aside class="notes"><p>&#39;in&#39; makes an interable and the value to the left has to be a string to compare or a variable that will become the string.</p>
</aside></script></section><section data-markdown><script type="text/template">

For the inclusionary inverse of "avoids", "uses_only", it's the same function with a "not" in front of "in":

```python
def uses_only(word, available):
    for letter in word:
        if letter not in available:
            return False
    return True
```

<aside class="notes"><p>and changed variable names..</p>
</aside></script></section><section data-markdown><script type="text/template">

For "uses_all", it'll be the same thing, but conditionals reversed:

```python
def uses_all(word, required):
    for letter in required:
        if letter not in word:
            return False
    return True
```

</script></section><section data-markdown><script type="text/template">

You can actually reuse code though for "uses_all":

```python
def uses_only(word, available):
    for letter in word:
        if letter not in available:
            return False
    return True

def uses_all(word, required):
    return uses_only(required, word)
```

</script></section><section data-markdown><script type="text/template">

For the "is_abcedarian" function, there are roughly 3 main ways to approach it:

- for loop
- recursion
- while loop

</script></section><section data-markdown><script type="text/template">

Using a for loop is a little messy since we have no idea where we are in the comparison:

```python
def is_abcedarian(word):
    prev = word[0]
    for letter in word:
        if letter < prev:
            return False
        prev = letter
    return True
```

</script></section><section data-markdown><script type="text/template">

Recursion is probably the best way, but can be a little confusion for novice programmers:

```python
def is_abcedarian(word):
    if len(word) <= 1:
        return True
    if word[0] > word[1]:
        return False
    return is_abcedarian[1:]
```

</script></section><section data-markdown><script type="text/template">

A while loop is cleaner than the for loop, but not by much:

```python
i = 0
while i < len(word)-1:
    if word[i+1] < word[i]:
        return false
    i = i + 1
return True
```

<aside class="notes"><p>because this is programming, there are other ways to code this including variations of the existing solutions above. We&#39;re just covering these 3.</p>
</aside></script></section><section data-markdown><script type="text/template">

Homework: Exercises 9.7 - 9.8.
Extra Credit: 9.9 - 5 pts

<aside class="notes"><p>Talk about project before homework, next slide.</p>
</aside></script></section></section><section  data-markdown><script type="text/template">

##### Project 1

##### [https://coder.run/1402-project1](https://coder.run/1402-project1)

</script></section></div>
        </div>

        <script src="./lib/js/head.min.js"></script>
        <script src="./js/reveal.js"></script>

        <script>
            function extend() {
              var target = {};
              for (var i = 0; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (source.hasOwnProperty(key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            }

            // Optional libraries used to extend on reveal.js
            var deps = [
              { src: './lib/js/classList.js', condition: function() { return !document.body.classList; } },
              { src: './plugin/markdown/marked.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
              { src: './plugin/markdown/markdown.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
              { src: './plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
              { src: './plugin/zoom-js/zoom.js', async: true },
              { src: './plugin/notes/notes.js', async: true },
              { src: './plugin/math/math.js', async: true }
            ];

            // default options to init reveal.js
            var defaultOptions = {
              controls: true,
              progress: true,
              history: true,
              center: true,
              transition: 'default', // none/fade/slide/convex/concave/zoom
              dependencies: deps
            };

            // options from URL query string
            var queryOptions = Reveal.getQueryHash() || {};

            var options = {"transition":"fade"};
            options = extend(defaultOptions, options, queryOptions);
        </script>


        <script>
            Reveal.initialize(options);
        </script>
    </body>
</html>
